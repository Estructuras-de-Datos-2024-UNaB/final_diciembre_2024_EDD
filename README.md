# Estructuras de Datos.  FINAL - DICIEMBRE  - 18 / 12 / 2024 - 

# Examen Final: "Universo Saga Cinematográfica de Matrix"

---
### Completar los siguientes Datos:

- **Nombre Y Apellido:**
- **Email:**
- **Año, Cuatrimestre, Comisión:**
- **Carrera:**
---

### <u>Modalidad:</u> 

- El Final es virtual pero sincrónico 

- Los/as alumnos/as deberán conectarse al Meet, con la cámara encendida y mostrar una identificación valida (DNI/DNU).

- El examen se realiza mediante la plataforma de Github Classroom.

- Debén accreder al examen y el Meet sincrónico mediante el programa Safe Exam Browser.

- Tendrán 3:30hs (tres horas y treinta minutos) para realizar el examen.

- Deben redactar las resoluciones en los archivos correspondientes a cada Ejercicio (i.e. `ejercicio1.py`, `ejercicio2.py`, etc.) 

- El examen se corrige al momento de la entrega. 

 <br> $~~~~~~~$ NOTA: DEBEN COMPLETAR LA PARTE SUPERIOR DE ESTE README CON SUS DATOS!!  <br>
 
---

#### **Ejercicio 1:. Encapsulamiento e Interfaces** 
   - Neo encuentra un programa encapsulado que controla la entrada y salida de personas a la Matrix. Define qué es una interfaz en el contexto de la Programación Orientada a Objetos y explica cómo podría usarse para representar este programa.

#### **Ejercicio 2: Estructuras de Datos Recursivas** 
   - Considera que las conexiones dentro de la Matrix pueden representarse como un grafo recursivo. Define un grafo y describe dos representaciones posibles. ¿Cuándo es preferible usar listas de adyacencia en lugar de matrices de adyacencia?

#### **Ejercicio 3: Análisis de Algoritmos** 
   - Trinity implementa un algoritmo para hackear un sistema en la Matrix. Explica qué es la notación O() y cómo se aplica para determinar el mejor, peor y promedio caso de un algoritmo de búsqueda dentro de un arreglo desordenado.

#### **Ejercicio 4: Problemas NP** 
   - Morpheus intenta encontrar el camino más corto para alcanzar un terminal dentro de la Matrix. Explica por qué el problema del camino más corto es considerado NP-completo y describe el uso del algoritmo de Dijkstra para resolverlo.

#### **Ejercicio 5: Árboles Binarios** 
   - Representa el proceso de decisión de Neo para elegir entre la píldora roja y la azul como un árbol binario. Implementa en Python un árbol con los nodos "Inicio", "Píldora Roja" y "Píldora Azul". Realiza un recorrido InOrden del árbol e imprime los nodos visitados.

#### **Ejercicio 6: Heap Binaria y Cola de Prioridades** 
   - El oráculo gestiona una cola de prioridad de eventos futuros en la Matrix. Implementa una estructura de Heap Binaria para gestionar los eventos según su importancia (prioridad). Incluye las operaciones de inserción y extracción del máximo.

#### **Ejercicio 7: Algoritmos de Recorrido** 
   - Diseña una función en Python para realizar un recorrido BFS en un grafo que representa las conexiones de la Matrix. Usa el siguiente conjunto de datos para el grafo:
     - Nodos: [A, B, C, D, E]
     - Aristas: [(A, B), (A, C), (B, D), (C, E), (D, E)]

#### **Ejercicio 8: Ordenamiento Topológico** 
   - El Arquitecto desea ordenar las dependencias entre programas para reconstruir la Matrix. Implementa un algoritmo de ordenamiento topológico en Python para el siguiente grafo dirigido:
     - Nodos: [A, B, C, D, E]
     - Aristas: [(A, B), (A, C), (B, D), (C, D), (D, E)]

#### **Ejercicio 9: Heap Binario para Planificación**
   - Smith utiliza un montículo binario (heap) para gestionar las tareas prioritarias en tiempo real. Implementa un heap mínimo en Python con soporte para operaciones de inserción, extracción del mínimo y disminución de clave. Prueba tu implementación con la siguiente lista de tareas y prioridades: [("Tarea A", 5), ("Tarea B", 3), ("Tarea C", 8), ("Tarea D", 1)].

#### **Ejercicio 10: Ruta Mínima en Grafos**
   - Neo necesita encontrar la ruta más corta para llegar a un terminal en un grafo ponderado que representa conexiones en la Matrix. Implementa el algoritmo de Dijkstra en Python y úsalo con el siguiente grafo:
     - Nodos: [1, 2, 3, 4, 5]
     - Aristas y pesos: [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]

#### **Ejercicio 11: Teoría (Estructuras de Datos)**  
**Tema**: Comparación de estructuras de datos.  
1. Explica las diferencias entre una pila y una cola, y da un ejemplo práctico del uso de cada una.  
2. ¿Por qué las listas enlazadas son más eficientes que las listas tradicionales para ciertas operaciones?

